<template>
    <require from="app/components/photo"></require>
    
    <h4 class="text-center">Background</h4>
    <p>
        FarmTrack consists of both a physical GPS receiver and logging unit, as well as a visualization platform
        through which farmers are able to view the data generated by their various vehicles.
    </p>
    
    <h4 class="text-center">The Device</h4>
    <p>
        The FarmTrack device originated purely as a logging device which could be connected via USB to any computer.
        It would be visible as a mass storage device and, paired with a conversion tool, its log files could be
        visualized in Google Earth.
    </p>
    
    <p>
        The device's primary selling points were its high quality GPS receiver, allowing for accuracies as good as 1.5m 
        on civilian GPS bands (measured as &sigma;<sub>1</sub>, or 1 standard deviation), as well as its rugged design
        and ease of use.
    </p>
    
    <p>
        With the second generation FarmTrack device our hardware subsidiary, <a href="http://www.etse.co.za">ETSE</a>,
        integrated a cellphone modem capable of EDGE data connections on the device. This enabled us to transmit the
        logged data in real-time to a remote server for analysis and storage.
    </p>
    
    <p class="text-center">
        <img src="/resources/farmtrack-device.png" alt="The FarmTrack Device" class="responsive-img">
        <br>
        <strong>FarmTrack Device</strong> A ruggedised GPS receiver and logging device with cellphone connectivity
    </p>
    
    <h4 class="text-center">My Brief</h4>
    <p>
        I was brought onto the project following failure to sell significant numbers of the traditional FarmTrack device.
        Our team was given the task of making FarmTrack a profitable venture by improving the user experience and enabling
        farmers to more effectively utilize the system.
    </p>
    
    <p class="text-center">
        <img src="/resources/farmtrack-old-website.png" alt="The Old FarmTrack Website" class="responsive-img">
        <br>
        <strong>Original FarmTrack Website</strong> showing its login prompt and tabular layout
    </p>
    
    <p>
        The original website had required users to extract log files from the devices (over USB) and upload them for conversion
        into KML format, allowing them to then be downloaded and visualized in Google Earth. It was developed in PHP by the
        original hardware development team and essentially served its purpose and no-more.
    </p>
    
    <p>
        Initially our plan involved developing a protocol and server which would allow devices to present their logs without
        requiring removal from the vehicles they were mounted to, however after further discussion with the stakeholders
        it became clear that a level of analytics was also required to help reduce operator workload.
    </p>
    
    <p>
        There was also significant pressure from all parties to improve the visual presentation of data and the website itself.
        (As a side note, the website contained 3 lines of CSS code - the rest done using legacy HTML attributes to set colours and,
        on the odd occasion, styles). 
    </p>
    
    <h4 class="text-center">Challenges</h4>
    <p>
        There were actually a rather wide range of challenges on this project, ranging from technical and operational
        to team and management ones. Many of the technical issues were quickly overcome, while operational ones required
        quite a bit more work to polish. At the end of the day though, they have all given me some great experience in
        both the technical and social fields.
    </p>
    
    <h5>Complex, Distributed, State Machines</h5>
    <p>
        When doing any kind of complex data analysis, it's very rare to see state machines not being employed. They provide
        a brilliant abstraction through which complex behaviours can be represented. At the start of the project I bumped
        heads with how one goes about building a state machine which handles a wide range of different states while
        still remaining easily maintainable and, perhaps more importantly, easily distributable.
    </p>
    
    <p>
        The specific problem I was trying to solve was how to generate state transition events like
        "This vehicle has just left a field" or "This vehicle has just completed spraying a row of crops". It quickly became
        clear that building a single state machine to handle this would be almost impossible and would make any future
        modifications dangerous.
    </p>
    
    <p>
        Instead, I opted to build a system which simplified integrating a number of smaller state machines and permitted
        those states to transfer into higher order machines. Obviously the state machine which determines whether a
        vehicle has entered a field is far simpler than one which determines when a vehicle has sprayed a row of crops.
        On the other hand, once you have the simpler components it becomes far easier to determine when a vehicle has
        sprayed a row.
    </p>
    
    <p>
        As far as allowing the state machines to operate safely in a cluster, the solution I adopted was to present a
        central state repository for each vehicle, this would be pulled in when the vehicle connected to a server and
        updated whenever a packet had been processed (persisted to Redis). This meant that, should a vehicle's device
        lose internet connectivity and connect to a new server, its latest valid state information would immediately
        be available there and it could continue working as expected.
        <br>
        This works thanks mainly to the fact that devices stream data over a long-lived socket connection, minimizing
        the amount of overhead needed to retrieve state information between packets.
    </p>
    
    <h5>Achieving Four-9s Stability</h5>
    <p>
        I'm going to be perfectly honest here, this was something I challenged myself to do rather than anything requested
        by management or our customers. That being said, it's something our customers have definitely come to appreciate and
        it has offered a great opportunity for me to learn some amazing tools. 
    </p>
    
    <p>
        FarmTrack's cluster is relatively complex, consisting of load balancers, redundant configuration servers, service
        discovery and a mirrored and sharded database cluster. It didn't start out like that however, with much of that being
        added in response to downtime events early in FarmTrack's lifespan - both as a result of infrastructure failures and
        application crashes. One of the more interesting failure cases involved the Linux Out Of Memory Killer nuking our
        process supervisor tool...
    </p>
    
    <p class="text-center">
        <img src="/resources/farmtrack-cluster.png" alt="The FarmTrack Cluster" class="responsive-img">
        <br>
        <strong>The FarmTrack Cluster</strong> showing the various components and their hard, and soft, communication channels. 
    </p>
    
    <p>
        The latest version of FarmTrack's cluster is deployed and managed by Ansible 2.0 and makes use of Consul for service
        discovery and configuration management. It has an integrated build server which mirrors the state of the application
        servers to enable 1:1 tests prior to deploying a version of the server. In addition to this, the build server enables
        us to rapidly rollback versions should a deployment fail.
    </p>
    
    <p>
        We use HAProxy to provide a unified entry point into the cluster for all public traffic, as well as gzip compression on
        compressible outbound data. It is configured on the fly by <a href="https://github.com/hashicorp/consul-template">consul-template</a>
        based on the health of various cluster nodes and the services they make available. This allows us to very easily add
        or remove nodes from the cluster, as well as providing circuit breaking in case a node fails.
    </p>
    
    <p>
        Internally, we use Consul's DNS provider to resolve services, giving us plenty of flexibility to change the cluster's
        topography without breaking things (even while the cluster is serving requests). This has made subsequent modifications
        or node replacements (generally for vertical scaling) absolutely trivial.
    </p>
    
    <h4 class="text-center">Interesting Lessons</h4>
    
    <h5>Having a Bodgeable System</h5>
    <p>
        FarmTrack has, since the project started, been very limited in terms of time available. Much of the work done on
        automating different aspects was driven by the need to work on other projects. This, combined with a very agile
        approach to development, has led to a system with very little excess fat. This is brilliant from a maintenance
        view, and regular refactoring has meant that adding new features is a breeze from a technical standpoint. On the
        other hand, it means that there is little in the way of available room to "bodge" functionality onto the system. 
    </p>
    
    <p>
        Specifically, now that the project has reached a relatively mature state, there is a lot of demand for marketing
        functionality - things like "Give me graphs showing how we've improved the accuracy of the analytics algorithms.".
        We're in a tricky position where our datasets are too big to manually compare them, but not yet big enough that
        daily variances can be disregarded in our accuracy estimates.
    </p>
    
    <p>
        Something which has led to a lot of irritation in that regard is that many of the team members have experience working
        on other, far more bloated, projects in which "hack a solution together" is the modus operandi and a feasible way
        to bypass writing a good implementation. This leads to estimates being undercut or requests like "A week to implement that
        is too long, just put something dirty together and get it done faster." - something which is often not possible.
    </p>
    
    <p>
        Looking back on the project, I'm not sure I would have done anything different on this front from a technical perspective,
        however I would definitely have spent more time educating the non-technical team members on the impact of this approach.
        I feel that having them aware of why it is not possible to "hack something together", or why it may not make sense given
        the time taken to do so, would have saved me many difficult discussions and a lot of emotional stress.
    </p>
    
    <h5>Document your APIs</h5>
    <p>
        Another decision which was made relatively early in FarmTrack's development cycle was that our external API should be
        properly documented (I opted to use <a href="http://apiary.io">Apiary</a>). This was initially seen as a waste of time
        by the management members of the team, something which wouldn't be used or could be satisfied through email correspondence.
    </p>
    
    <p>
        It is important to remember that I am the only developer working on the server and frontend aspects of the project, while
        hardware development (and all their supporting infrastructure) was managed by a team in a different building. This made
        routine communication outside of our weekly progress meetings rare. As the system matured, it became very important for
        the hardware team to have access to our low-level API for various diagnostic details and automation of their workflows.
    </p>
    
    <p>
        Having a fully documented API meant that they were able to get up and running in most cases without needing to contact me.
        It also meant that, through the 600+ commits to the server and over 200 deployments, their workflow tools have yet to break
        or fail to work as expected. 
    </p>
    
    <p>
        Another very interesting benefit of using Apiary for our API documentation was that it could be parsed by a machine and converted
        to a JSON representation. This allowed me to build support into the frontend for not only automatically validating API data
        prior to sending it, but also for running the user interface without a corresponding server - allowing me to test it or
        demonstrate it long before the server was complete.
    </p>
    
    <h5>Keep your APIs Atomic</h5>
    <p>
        One of the big design decisions from the outset of the FarmTrack project was to keep the various APIs as simple as possible,
        each dealing with a specific task and avoiding cross-pollination as much as possible. Specifically, I meant to avoid situations
        in which API methods were put together to solve a specific use case - rather designing them to surface or mutate specific data.
    </p>
    
    <p>
        Initially this allowed me to implement them very rapidly, however as the project evolved and requirements shifted the emphasis
        on exposing data rather than satisfying a use case meant that changes to the frontend very rarely, if ever, required changes
        to the API or its implementation. This enabled us to offer both a stable, customer facing, interface as well as a beta testing
        interface to test out new features or showcase progress to prospective clients. This could be achieved without any modifications
        to the server and without the risk of affecting the way in which the production interface behaved.
    </p>
    
    <p>
        Another big benefit of keeping API methods focussed on a single atomic task was that response times across the different API methods
        remained relatively consistent - allowing us to easily manage performance and scaling of the system.
    </p>
    
    <h5>Instrument your Performance</h5>
    <p>
        This was something I initially adopted in <a route-href="route: project; params.bind: { id: 'frontier' }">Frontier</a> but expanded
        on with FarmTrack. Specifically, the tracking of how long it takes your server to process each and every request it receives from
        a remote client.
    </p>
    
    <p>
        My intention FarmTrack's performance tracking implementation was to keep database load to a minimum (we're already very write heavy
        as a result of the data we receive from the devices), allow us to view performance information at different resolutions over a period
        of time and also ensure that we didn't use an exorbitant amount of space to track that performance information. I also wanted to easily
        be able to extend it to include additional information if needed, as well as keeping document size expansion to a minimum (as it requires
        MongoDB to move documents around on disk - a slow operation).
    </p>
    
    <pre><code class="typescript">
export interface PerformanceLog {
    verb: string;
    method: string;
    
    minutes: PerformanceBucket[];
    hours: PerformanceBucket[];
    days: PerformanceBucket[];
    total: PerformanceBucket;
}

export interface PerformanceBucket {
    requests: number;
    time: number;
    maxTime: number;
}
</code></pre>
    <p class="text-center"><strong>Performance Log Schema</strong> used to track performance of a specific API method over a period of time.</p>
    
    <p>
        The resulting schema allowed me to store one document per API-method, keeping the amount of data we would be storing relatively low while
        at the same time keeping track of 1 minute resolution data for the past hour, 1 hour resolution data for the last day and 1 day resolution
        data for the last week. It was also very easy to extend the performance buckets with additional data, like time-to-first-byte.
    </p>
    
    <pre><code class="typescript">
export class PerformanceLogger {
    constructor(private database: Database) {
        
    }

    logRequest(verb: string, method: string, responseTime: number): Promise.Thenable {
        return this.database.PerformanceLog.update({
            verb: verb,
            method: method
        }, {
            $inc: {
                'minutes.0.requests': 1,
                'hours.0.requests': 1,
                'days.0.requests': 1,
                'minutes.0.time': responseTime,
                'hours.0.time': responseTime,
                'days.0.time': responseTime,
                'total.requests': 1,
                'total.time': responseTime
            },
            $max: {
                'minutes.0.maxTime': responseTime,
                'hours.0.maxTime': responseTime,
                'days.0.maxTime': responseTime,
                'total.maxTime': responseTime
            }
        }, {
            w: '0',
            upsert: true
        });
    }
    
    startTimedRequest(): (verb: string, method: string) => void {
        let startTime = process.hrtime();
        
        return (verb: string, method: string) => {
            let responseTime = process.hrtime(startTime);
            let responseTimeMS = responseTime[0] * 1e3 + responseTime[1] * 1e-6;
            
            this.logRequest(verb, method, responseTimeMS).catch(err => {
                console.error(`Failed to log performance data: ${err.stack}`);
            });
        };
    }
    
    rotate(period: string, capacity: number): Promise.Thenable {
        return this.database.PerformanceLog.update({}, {
            $push: {
                [period]: {
                    $each: [&gt;PerformanceBucket&lt;{ requests: 0, time: 0, maxTime: 0 }],
                    $position: 0,
                    $slice: capacity
                }
            }
        }, { multi: true });
    }
}
    </code></pre>
    <p class="text-center"><strong>Performance Tracking</strong> using the MongoDB Upsert operation to minimize requests.</p>
    
    <p>
        Similarly, the code used to actually track the performance data was very straightforward - using MongoDB's upsert operation
        to remove the need for a query and insert if the API-method didn't exist, and rotations being triggered by a
        <code class="bash">cron</code> script.
    </p>
    
    <h4 class="text-center">The Result</h4>
    
    <photo src="/resources/farmtrack-website.png"
        alt="The FarmTrack Website"
        title="FarmTrack Website"
        subtitle="demonstrating some of the data we visualize for our customers.">
    </photo>
</template>